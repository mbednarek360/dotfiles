"use strict";
/**
 * Some code borrowed from https://github.com/tarruda/node-msgpack5rpc
 */
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const msgpack = require("msgpack-lite");
const buffered_1 = require("./buffered");
const types_1 = require("../api/types");
class Response {
    constructor(encoder, requestId) {
        this.encoder = encoder;
        this.requestId = requestId;
    }
    send(resp, isError) {
        if (this.sent) {
            throw new Error(`Response to id ${this.requestId} already sent`);
        }
        this.encoder.write(msgpack.encode([
            1,
            this.requestId,
            isError ? resp : null,
            !isError ? resp : null,
        ]));
        this.sent = true;
    }
}
class Transport extends events_1.EventEmitter {
    constructor() {
        super();
        this.pending = new Map();
        this.nextRequestId = 1;
        const codec = this.setupCodec();
        this.encodeStream = msgpack.createEncodeStream({ codec });
        this.decodeStream = msgpack.createDecodeStream({ codec });
        this.decodeStream.on('data', (msg) => {
            this.parseMessage(msg);
        });
        this.decodeStream.on('end', () => {
            this.detach();
            this.emit('detach');
        });
    }
    setupCodec() {
        const codec = msgpack.createCodec();
        types_1.Metadata.forEach(({ constructor }, id) => {
            codec.addExtPacker(id, constructor, (obj) => msgpack.encode(obj.data));
            codec.addExtUnpacker(id, data => new constructor({
                transport: this,
                client: this.client,
                data: msgpack.decode(data),
            }));
        });
        this.codec = codec;
        return this.codec;
    }
    attach(writer, reader, client) {
        this.encodeStream = this.encodeStream.pipe(writer);
        const buffered = new buffered_1.default();
        reader.pipe(buffered).pipe(this.decodeStream);
        this.writer = writer;
        this.reader = reader;
        this.client = client;
    }
    detach() {
        this.encodeStream.unpipe(this.writer);
        this.reader.unpipe(this.decodeStream);
    }
    request(method, args, cb) {
        this.nextRequestId = this.nextRequestId + 1;
        this.encodeStream.write(msgpack.encode([0, this.nextRequestId, method, args], {
            codec: this.codec,
        }));
        this.pending.set(this.nextRequestId, cb);
    }
    notify(method, args) {
        this.encodeStream.write([2, method, args]);
    }
    parseMessage(msg) {
        const msgType = msg[0];
        if (msgType === 0) {
            // request
            //   - msg[1]: id
            //   - msg[2]: method name
            //   - msg[3]: arguments
            this.emit('request', msg[2].toString(), msg[3], new Response(this.encodeStream, msg[1]));
        }
        else if (msgType === 1) {
            // response to a previous request:
            //   - msg[1]: the id
            //   - msg[2]: error(if any)
            //   - msg[3]: result(if not errored)
            const id = msg[1];
            const handler = this.pending.get(id);
            this.pending.delete(id);
            handler(msg[2], msg[3]);
        }
        else if (msgType === 2) {
            // notification/event
            //   - msg[1]: event name
            //   - msg[2]: arguments
            this.emit('notification', msg[1].toString(), msg[2]);
        }
        else {
            this.encodeStream.write([1, 0, 'Invalid message type', null]);
        }
    }
}
exports.Transport = Transport;
