"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const util = require("util");
const vm = require("vm");
const lodash_1 = require("lodash");
const logger_1 = require("../utils/logger");
const devnull_1 = require("../utils/devnull");
const NvimPlugin_1 = require("./NvimPlugin");
// eslint-disable-next-line
const Module = require('module');
const REMOVED_GLOBALS = [
    'reallyExit',
    'abort',
    'chdir',
    'umask',
    'setuid',
    'setgid',
    'setgroups',
    '_kill',
    'EventEmitter',
    '_maxListeners',
    '_fatalException',
    'exit',
    'kill',
];
function removedGlobalStub(name) {
    return () => {
        throw new Error(`process.${name}() is not allowed in Plugin sandbox`);
    };
}
// @see node/lib/internal/module.js
function makeRequireFunction() {
    const require = ((p) => this.require(p));
    require.resolve = (request) => Module._resolveFilename(request, this);
    require.main = process.mainModule;
    // Enable support to add extra extension types
    require.extensions = Module._extensions;
    require.cache = Module._cache;
    return require;
}
// @see node/lib/module.js
function compileInSandbox(sandbox) {
    // eslint-disable-next-line
    return function (content, filename) {
        const require = makeRequireFunction.call(this);
        const dirname = path.dirname(filename);
        // remove shebang
        // eslint-disable-next-line
        const newContent = content.replace(/^\#\!.*/, '');
        const wrapper = Module.wrap(newContent);
        const compiledWrapper = vm.runInContext(wrapper, sandbox, { filename });
        const args = [this.exports, require, this, filename, dirname];
        return compiledWrapper.apply(this.exports, args);
    };
}
function createDebugFunction(filename) {
    return (...args) => {
        const debugId = path.basename(filename);
        const sout = util.format.apply(null, [`[${debugId}]`].concat(args));
        logger_1.logger.info(sout);
    };
}
function createSandbox(filename) {
    const module = new Module(filename);
    module.paths = Module._nodeModulePaths(filename);
    const sandbox = vm.createContext({
        module,
        console: {},
    });
    lodash_1.defaults(sandbox, global);
    // Redirect console calls into logger
    Object.keys(console).forEach((k) => {
        if (k === 'log') {
            sandbox.console.log = createDebugFunction(filename);
        }
        else if (k in logger_1.logger) {
            sandbox.console[k] = logger_1.logger[k];
        }
    });
    sandbox.require = function sandboxRequire(p) {
        const oldCompile = Module.prototype._compile;
        Module.prototype._compile = compileInSandbox(sandbox);
        const moduleExports = sandbox.module.require(p);
        Module.prototype._compile = oldCompile;
        return moduleExports;
    };
    // patch `require` in sandbox to run loaded module in sandbox context
    // if you need any of these, it might be worth discussing spawning separate processes
    sandbox.process = lodash_1.omit(process, REMOVED_GLOBALS);
    REMOVED_GLOBALS.forEach(name => {
        sandbox.process[name] = removedGlobalStub(name);
    });
    const devNull = new devnull_1.DevNull();
    // read-only umask
    sandbox.process.umask = (mask) => {
        if (typeof mask !== 'undefined') {
            throw new Error('Cannot use process.umask() to change mask (read-only)');
        }
        return process.umask();
    };
    sandbox.process.stdin = devNull;
    sandbox.process.stdout = devNull;
    sandbox.process.stderr = devNull;
    return sandbox;
}
// inspiration drawn from Module
function createPlugin(filename, nvim, options = {}) {
    try {
        const sandbox = createSandbox(filename);
        logger_1.logger.debug(`createPlugin.${filename}.clearCache: ${options && !options.cache}`);
        // Clear module from cache
        if (options && !options.cache) {
            try {
                delete Module._cache[require.resolve(filename)];
            }
            catch (err) {
                // possible this doesn't exist in cache, ignore
            }
        }
        // attempt to import plugin
        // Require plugin to export a class
        const defaultImport = sandbox.require(filename);
        const plugin = (defaultImport && defaultImport.default) || defaultImport;
        if (typeof plugin === 'function') {
            return new NvimPlugin_1.NvimPlugin(filename, plugin, nvim);
        }
    }
    catch (err) {
        const file = path.basename(filename);
        logger_1.logger.error(`[${file}] ${err.stack}`);
        logger_1.logger.error(`[${file}] Error loading child ChildPlugin ${filename}`);
    }
    // There may have been an error, but maybe not
    return null;
}
function loadPlugin(filename, nvim, options = {}) {
    try {
        return createPlugin(filename, nvim, options);
    }
    catch (err) {
        // logger.error(`Could not load plugin "${filename}":`, err, err.stack);
        return null;
    }
}
exports.loadPlugin = loadPlugin;
